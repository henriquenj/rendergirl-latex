\documentclass[a4paper]{sbgames}               % final
\usepackage{times}
\usepackage{graphicx}

%% use this for zero \parindent and non-zero \parskip, intelligently.
\usepackage{parskip}

%% the 'caption' package provides a nicer-looking replacement
\usepackage[labelfont=bf,textfont=it]{caption}

\usepackage{url}

%% Paper title.
\title{A modular GPU raytracer using OpenCL for non-interactive graphics}

%% Author and Affiliation (multiple authors). Use: and between authors

\author{Henrique Nunes Jung\\ Univesidade do Vale do Rio dos Sinos
}
\contactinfo{\{henriquenj\}@gmail.com
}
%% Keywords that describe your work.
\keywords{GPGPU, OpenCL, computer graphics, raytracing}

%% Start of the paper
% Attention: As you need to insert EPS images in Postscript,
% you need to insert PDF images into PDFs.
% In the text, extensions cancbe omitted (latex use .eps, pdflatex get .pdf)
% To convert them: epstopdf myimage.eps
\begin{document}

\teaser{

}

%% The ``\maketitle'' command must be the first command after the
%% ``\begin{document}'' command. It prepares and prints the title block.

\maketitle

%% Abstract section.

\begin{abstract}

  In this paper we describe the implementation of a modular raytracer
  renderer suitable for running inside the OpenCL architecture.
\end{abstract}

%% The ``\keywordlist'' command prints out the keywords.
\keywordlist
\contactlist

\section{Introduction}

Platforms for general purpose computing using GPUs started when NVIDIA
released its GPGPU platform called CUDA, which is capable of running
only on NVIDIA hardware. OpenCL was born sometime later using the
label \emph{heteregenous computing}, in order to specifies that the
platform was supported by many kinds of hardware and computers
processors, including CPUs and non-NVIDIA GPUs, which could be
implemented by any vendor interested in developing hardware focused on
parallel computation.

Within this context, this work aims to provide a modular plugin-based
raytracer software that takes advantage of the parallel capabilities
of modern GPUs while maintaing hardware agnosticism by using the
portability OpenCL provides to hardware vendors and developers. By
being modular, it's also capable of running inside larger 3D suites
such as Blender, this way we can delegate other tasks to the host 3D
program and focuses on the rendering tasks. Work is focused on
modularity and portability, both of hardware and operating system. The
first immediate target market is CGI for architecture, due to simpler
illumination models and lightning effects used in this field.

We developed a C++ application with wrappers for
Python %TODO: do I really need a python wrapper?
and C++ and a reference plugin for Blender, used to validate the
plugin architecture. The code has only portable system calls and
OpenCL function calls. In order to guarantee compilation on multiples
compilers, CMake was used as build system. Development happens on
GitHub, which contains the code and issue
tracker\cite{RenderGirl}.

Intrinsic problems that arrives with GPU raytracing includes the cost
of synchronizing and stoping working threads, poor branch prediction,
high latency of different OpenCL memory models, high latency on the
bus used between GPU and main memory (usually PCI Express) and the
broad variety of GPUs and OpenCL capable hardware, which can generate
different results on different setups.
% TODO add benefits of programming using GPUs, start with "by contrast"

While this software is intended to work on all hardware capable of
running OpenCL, we tried to focus on GPUs, so optimization for this
type of processor received preference. It's also worth noting that
this work does not have real-time constraints and it is designed to be
used as an \emph{offline} raytracing, so image quality is more
important than rendering times.

\section{Related Work}
\label{sec:related-work}

Applications that provides GPU rendering capabilities for
non-interactive graphics include Blender Cycles\cite{Cycles} , Octane
render \cite{Octane}, V-Ray renderer \cite{VRAY}, Redshift
\cite{Redshift} and Indigo renderer \cite{Indigo}.

Indigo and Cycles claims to run using the OpenCL architecture. Cycles
is the only one that is free software; originally it only supported
CUDA-capable devices, but newer versions of Blender ship with Cycles
that works with limited features also on OpenCL, although the
developers specifies that CUDA platform is more mature.\cite{Cycles}
Also Cycles takes a different approach for device abstraction by
performing \emph{platform abstraction} by issuing commands to a common
\emph{device interface} that can redirect function calls to CUDA,
OpenCL, CPU or network; although the latter is still
experimental. \cite{CyclesDevel}. Our work delegate the device
abstraction entirely to OpenCL.

Recent related work on the computing literature includes: Widmer and
% TODO: should I mention somehow that I copied the abstract
% description of those guys?
colleagues proposes efficient acceleration structure for real-time
screen space raytracing \cite{Widmer}. Ravichandran proposes a
parallel divide and conquer raytracing suited for GPUs
\cite{Ravichandran}. Shumskiy and Parshin write about the difference
between GPUs architectures and its impact on the performance of
ray-triangle intersection algorithms \cite{Shumskiy}, which is a
critical part of a raytracer, adding complexity when trying to
optimize the code.

Our own implementation relies on ray-triangle intersection algorithm
developed by MÃ¶ller %TODO: moller name is lacking a character,
                    %investigate later
and Trumbore that aims to be fast by avoiding
ray-plane intersections\cite{moller}.

\section{Methodology}
\label{sec:methodology}

We developed a GPU raytracer using the OpenCL architecture called
\emph{RenderGirl} licensed under GPL. Our work is entirely free
software since it's inception, aiming to be useful to architects
interested in using their GPU hardware for rendering models. We try not
to pose any restriction on the use of the software regarding its host
program, so anyone can implement their own interfaces.

Most part of the code is written using C++, with small portions
written in Python and OpenCL C. Daily work on the code was done on the
GitHub page of the project\cite{RenderGirl}. Tools used in the
development include Visual Studio for project files and compilation
under Windows, Git for source control, CMake for cross platform
building. GCC and Clang were used as compilers under Unix platforms.

The host program of RenderGirl is Blender, which provides all the base
functionality of a 3D software suite. RenderGirl connects with Blender
through its Python API and implements a \emph{RenderEngine}
interface. The host software performs all communication with the final
user through its own GUI.

The software can also run as an standalone executable file through its
command-line interface. This interface has minimum dependencies and
does not output any file, just reports if the rendering was successful.

\section{Conclusion}
\label{sec:conclusion}

\section*{Acknowledgments}


\bibliographystyle{sbgames}
\bibliography{references}
\end{document}
