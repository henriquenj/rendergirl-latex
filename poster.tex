%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% a0poster Portrait Poster
% LaTeX Template
% Version 1.0 (22/06/13)
%
% The a0poster class was created by:
% Gerlinde Kettl and Matthias Weiser (tex@kettl.de)
% Modified by Henrique Jung
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a0,portrait]{a0poster}

\usepackage{multicol} % This is so we can have multiple columns of text side-by-side
\columnsep=100pt % This is the amount of white space between the columns in the poster
\columnseprule=3pt % This is the thickness of the black line between the columns in the poster

\usepackage[svgnames]{xcolor} % Specify colors by their 'svgnames',
                              % for a full list of all colors
                              % available see here:
                              % http://www.latextemplates.com/svgnames-colors

\usepackage{times} % Use the times font
% \usepackage{palatino} % Uncomment to use the Palatino font

\usepackage[scaled=2]{helvet}
\tiny

\usepackage{graphicx} % Required for including images
\graphicspath{{figures/}} % Location of the graphics files
\usepackage{booktabs} % Top and bottom rules for table
\usepackage[font=small,labelfont=bf]{caption} % Required for specifying captions to tables and figures
\usepackage{amsfonts, amsmath, amsthm, amssymb} % For math fonts, symbols and environments
\usepackage{wrapfig} % Allows wrapping text around tables and figures

\begin{document}

\begin{minipage}[b]{0.75\linewidth}
  \veryHuge \color{NavyBlue} \textbf{A modular GPU raytracer using
    OpenCL for non-interactive graphics} \color{Black}\\[2cm] % Title
  \huge \textbf{Henrique Nunes Jung \& Vinicius Jurinic
    Cassol}\\[0.5cm] % Author(s)
  \huge Universidade do Vale do Rio dos
  Sinos\\[0.4cm] % University/organization
  \Large \texttt{henriquenj@gmail.com} \\
  \Large \texttt{vjcassol@unisinos.br} \\
  \
\end{minipage}
%
\begin{minipage}[b]{0.25\linewidth}
\includegraphics[width=20cm]{logo_unisinos.png}\\
\end{minipage}

\vspace{1cm} % A bit of extra whitespace between the header and poster content

%----------------------------------------------------------------------------------------

\begin{multicols}{2} % This is how many columns your poster will be
                     % broken into, a portrait poster is generally
                     % split into 2 columns

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------


\color{Navy} % Navy color for the abstract

\section*{Abstract}
\large

We describe the development of a modular plugin based raytracer
renderer called \emph{RenderGirl} suitable for running inside the
OpenCL framework. We aim to take advantage of heterogeneous computing
devices such as GPUs and many-core CPUs, focusing on parallelism. We
implemented the traditional partitioning scheme called \emph{bounding
  volume hierarchies}, where each scene is hierarchically subdivided
into axis-aligned bounding boxes, so a ray may only need to traverse a
subset of geometry by traversing the BVH and discarding objects it
surely cannot hit, optimizing the rendering process. These structures
were implemented on a many-core high parallel architecture suitable
for OpenCL, which needed a specific binary tree structure
implementation ready for stackless traversal on GPUs. RenderGirl is
split between two main portions: Core and Interface, where the Core
portions provide the bulk of ray-tracing operations and manage the
communication with OpenCL; and the interfaces provide communication
with a given host program, seeking modularity.

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

\color{Black} % SaddleBrown color for the introduction
\normalsize
\section*{Introduction}

This work aims to provide a modular plugin-based raytracer software
that takes advantage of the parallel capabilities of modern GPUs while
maintaining hardware agnosticism by using the portability OpenCL
provides to hardware vendors and developers. By being modular, it's
also capable of running inside larger 3D suites such as Blender, this
way we can delegate other tasks to the host 3D program and focus on
the rendering tasks. We developed a C++ application and a reference
plugin for Blender, used to validate this architecture. The code has
only portable system calls and OpenCL function calls. We also
developed a variant of the BVH partitioning structure suitable for
stackless traversal on the GPU.

Our contributions include:

\begin{itemize}
  \item A renderer independent of a given 3D software.
  \item A raytracer designed to take advantage of parallel
    computation capabilities of modern GPUs and other OpenCL-capable
    devices.
  \item A modular architecture with replaceable components that
    communicates with a known interface.
  \item Usage of acceleration structures suitable for storing scene
    information inside OpenCL architecture.
\end{itemize}

%----------------------------------------------------------------------------------------
%	ARCHITECTURE
% ----------------------------------------------------------------------------------------

\section*{Architecture}

RenderGirl is composed of a \emph{core} that communicates with a given
\emph{interface}.

The core portion is a static library that provides an API for
receiving the 3D scene structure - vertices, triangles, objects,
cameras and lights - and the OpenCL device selection. It performs all
of the communication between OpenCL and the interfaces, handling its
context.

The interfaces can be anything from executables to dynamic libraries,
depending on the plugin interface provided by the host 3D
program. Interfaces link themselves to the core at compile time and
translate all the requests from the host program.

\subsection*{Acceleration structures}

The process of using acceleration structures is usually divided in two
steps: \emph{construction} and \emph{traversal}. For the construction
step, we implemented the same method as described by Kay and
Kajiya\cite{kay1986ray}, which generates a binary balanced tree
containing the objects of the scene. On the traversal step, we
implemented the traversal algorithm described by Thrane and Simonsen
in their master thesis\cite{Thrane}, which generates a \emph{traversal
  array} from the tree, which is suitable for stackless traversal on
GPU. Each object is then only tested with an \emph{axis-aligned
  bounding boxes} representing either an object or an internal node of
the tree.

\begin{center}\vspace{1cm}
\includegraphics[width=0.8\linewidth]{bvh_rendered}
\captionof{figure}{ \color{Black} Visualization of the BVH as a
  tree. The numbers indicate the order of visiting. Dotted arrows
  represent where the traversal should resume if the ray fails to hit
  the AABB. 9 is the global escape index. Each leaf node holds an
  index to the global array of objects, here depicted as a triangle.}
\end{center}\vspace{1cm}

\begin{center}\vspace{1cm}
\includegraphics[width=0.8\linewidth]{traversal_array}
\captionof{figure}{\color{Black} Visualization of the BVH as in the
  traversal array.}
\end{center}\vspace{1cm}


%----------------------------------------------------------------------------------------
%	RESULTS
%----------------------------------------------------------------------------------------

\section*{Results}

We tested our raytracer implementation by running it from Blender using
a variety of scene configurations. We aim to test different kinds of
object distributions in order to test how the BVH performs on each
case. We used the following test scenes:

\begin{itemize}
\item Scene 1: A simple scene depicting a table and some kitchen
  objects. It contains 21.424 vertices, 42,848 triangles divided into
  28 objects.
\item Scene 2: The same scene as before but with several evenly
  distributed tables. It contains 203.644 vertices, 405.242 triangles
  divided into 233 objects.
\item Scene 3: A scene with a single whale object containing 8.432
  vertices and 16.764 triangles.
\item Scene 4: A scene depicting a cabin. It contains 93.570 vertices,
  178.104 triangles divided into 250 objects. See
  figure~\ref{fig:cabin_scene}.
\end{itemize}

All tests were executed on a NVIDIA GeForce GTX 970 using driver
version 353.30. The OpenCL specification version used by this driver
is 1.2.

\begin{center}\vspace{1cm}
\includegraphics[width=0.8\linewidth]{cabin}
\captionof{figure}{ \color{Black} A scene rendered by RenderGirl}
\label{fig:cabin_scene}
\end{center}\vspace{1cm}


\begin{center}\vspace{1cm}
\includegraphics[width=0.8\linewidth]{results_rendered}
\captionof{figure}{ \color{Black} }
\end{center}\vspace{1cm}



\bibliographystyle{plain} % Plain referencing style
\bibliography{references} % Use the example bibliography file sample.bib

%----------------------------------------------------------------------------------------

\end{multicols}
\end{document}