\documentclass[a4paper]{sbgames}               % final
\usepackage{times}
\usepackage{graphicx}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

%% use this for zero \parindent and non-zero \parskip, intelligently.
\usepackage{parskip}

%% the 'caption' package provides a nicer-looking replacement
\usepackage[labelfont=bf,textfont=it]{caption}

\usepackage{url}

%% Paper title.
\title{A modular GPU raytracer using OpenCL for non-interactive graphics}

%% Author and Affiliation (multiple authors). Use: and between authors

\author{Henrique Nunes Jung\\ Univesidade do Vale do Rio dos Sinos
}
\contactinfo{\{henriquenj\}@gmail.com
}
%% Keywords that describe your work.
\keywords{GPGPU, OpenCL, computer graphics, raytracing}

%% Start of the paper
% Attention: As you need to insert EPS images in Postscript,
% you need to insert PDF images into PDFs.
% In the text, extensions cancbe omitted (latex use .eps, pdflatex get .pdf)
% To convert them: epstopdf myimage.eps
\begin{document}

\teaser{

}

%% The ``\maketitle'' command must be the first command after the
%% ``\begin{document}'' command. It prepares and prints the title block.

\maketitle

%% Abstract section.

\begin{abstract}

  In this paper we describe the implementation of a modular raytracer
  renderer suitable for running inside the OpenCL architecture.
\end{abstract}

%% The ``\keywordlist'' command prints out the keywords.
\keywordlist
\contactlist

\section{Introduction}

Platforms for general purpose computing using GPUs started when NVIDIA
released its GPGPU platform called CUDA, which is capable of running
only on NVIDIA hardware. OpenCL was born sometime later using the
label \emph{heteregenous computing}, in order to specifies that the
platform was supported by many kinds of hardware and computers
processors, including CPUs and non-NVIDIA GPUs, which could be
implemented by any vendor interested in developing hardware focused on
parallel computation.

Within this context, this work aims to provide a modular plugin-based
raytracer software that takes advantage of the parallel capabilities
of modern GPUs while maintaing hardware agnosticism by using the
portability OpenCL provides to hardware vendors and developers. By
being modular, it's also capable of running inside larger 3D suites
such as Blender, this way we can delegate other tasks to the host 3D
program and focuses on the rendering tasks. Work is focused on
modularity and portability, both of hardware and operating system. The
first immediate target market is CGI for architecture, due to simpler
illumination models and lightning effects used in this field.
% TODO: add here the method of BSP once it's selected

We developed a C++ application with wrappers for
Python %TODO: do I really need a python wrapper?
and C++ and a reference plugin for Blender, used to validate the
plugin architecture. The code has only portable system calls and
OpenCL function calls. In order to guarantee compilation on multiples
compilers, CMake was used as build system. Development happens on
GitHub, which contains the code, issue tracker and
documentation\cite{RenderGirl}.

Intrinsic problems that arrives with GPU raytracing includes the cost
of synchronizing and stoping working threads, poor branch prediction,
high latency of different OpenCL memory models, high latency on the
bus used between GPU and main memory (usually PCI Express) and the
broad variety of GPUs and OpenCL capable hardware, which can generate
different results on different setups.
% TODO add benefits of programming using GPUs, start with "by contrast"

While this software is intended to work on all hardware capable of
running OpenCL, we tried to focus on GPUs, so optimization for this
type of processor received preference. It's also worth noting that
this work does not have real-time constraints and it is designed to be
used as an \emph{offline} raytracing, so image quality is more
important than rendering times.

\section{Related Work}
\label{sec:related-work}

Applications that provides GPU rendering capabilities for
non-interactive graphics include Blender Cycles\cite{Cycles} , Octane
render \cite{Octane}, V-Ray renderer \cite{VRAY}, Redshift
\cite{Redshift} and Indigo renderer \cite{Indigo}.

Indigo and Cycles claims to run using the OpenCL architecture. Cycles
is the only one that is free software; originally it only supported
CUDA-capable devices, but newer versions of Blender ship with Cycles
that works with limited features also on OpenCL, although the
developers specifies that CUDA platform is more mature \cite{Cycles}.
Also Cycles takes a different approach for device abstraction by
performing \emph{platform abstraction} by issuing commands to a common
\emph{device interface} that can redirect function calls to CUDA,
OpenCL, CPU or network; although the latter is still experimental
\cite{CyclesDevel}. Our work delegate the device abstraction entirely
to OpenCL.

Recent related work on the computing literature includes: Áfra and
Szirmay-Kalos propose a novel traversal algorithm for BVH that doesn't
uses a stack, and can execute both on CPU and GPU platforms. They
introduce the concept of \emph{bitstack}, which is an integer used in
the place of a stack \cite{Afra}. Kalajanov and colleagues propose an
acceleration structure using hierarchical two-level grids implemented
in CUDA, which can eliminated problems arriving from using a single
uniform grid for subdividing a scene. They call "teapot in a stadium
problem", where a great amount of objects is allocated on a single
cell of the uniform grid \cite{Kalojanov}. Ravichandran and colleagues
proposes a parallel divide and conquer raytracing suited for
GPUs. Divide and conquer ray tracing remove the need of creating an
explicit aceleration structures once per frame, instead it creates an
aproximation using bound boxes \cite{Ravichandran}. Shumskiy and
Parshin write a comparative study of ray-triangle intersection
algorithms, how they perform on GPU hardware and how BVH acceleration
structures can be optimized for each one. They point out that some of
their results differs from generation to generation of the same line
of GPUS due to change in the micro-architecture.
% TODO: this last sentece should go to other section, more specific
\cite{Shumskiy}. Wong and colleagues propose an optimizatin method for
GPU ray tracing by dividing objects into view-sets based on light and
camera position, the BVH is then built using these views-sets, this
way the amount of triangles on the BVH is reduced \cite{Wong}. A great
portion of these works deal with acceleration structures for GPU
raytracing - e.g. kd-trees, BVHs -, which indicates the complexity of
these structures on GPU hardware.

Our own implementation relies on ray-triangle intersection algorithm
developed by Möller and Trumbore that aims to be fast by avoiding
ray-plane intersections\cite{moller}.

\section{Methodology}
\label{sec:methodology}

We developed a GPU raytracer using the OpenCL architecture called
\emph{RenderGirl} licensed under GPL. Our work is entirely free
software since it's inception, aiming to be useful to architects
interested in using their GPU hardware for rendering models. We try not
to pose any restriction on the use of the software regarding its host
program, so anyone can implement their own interfaces.

Most part of the code is written using C++, with small portions
written in Python and OpenCL C. Daily work on the code was done on the
GitHub page of the project\cite{RenderGirl}. Tools used in the
development include Visual Studio for project files and compilation
under Windows, Git for source control, CMake for cross platform
building. GCC and Clang were used as compilers under Unix platforms.

The host program of RenderGirl is Blender, which provides all the base
functionality of a 3D software suite. RenderGirl connects with Blender
through its Python API and implements a \emph{RenderEngine}
interface. The host software performs all communication with the final
user through its own GUI.

The software can also run as an standalone executable file through its
command-line interface. This interface has minimum dependencies and
does not output any file, just reporting if the rendering was successful.

We don't try to implement features that are not intrinsic related with
rendering, so RenderGirl delegates other tasks to the host program as
much as possible. This include loading of 3D models, user interface
interactions, image presentation and image saving. We believe this is
most useful and optimized way to solve the problem at hand.

\section{Conclusion}
\label{sec:conclusion}

\section*{Acknowledgments}


\bibliographystyle{sbgames}
\bibliography{references}
\end{document}
